# Минимальный запуск — что для этого надо?

## Предполагаемый порядок

1. создать `saga` - это аналог объявления

   ```javascript
   function* mySaga() {
     /*...*/
   }
   ```

2. `createSagaMiddleware()`, `createStore()` -
   как в `redux` и `redux-saga`.

3. нужно ли `sagaMiddleware.run(mySaga)`?

4. `dispatch(launchAction)`

## Что влияет на требуемые действия в предполагаемом порядке запуска?

- нужно указать корневую `saga` от которой всё разворачивается.<br/>
  И тут есть пару аргументов:
  - `saga-runtime` должен как-то получить ссылки
    на фактические функции, которые ему исполнять.
  - `saga-runtime` всё хранит в виде объектов, т.е. о функциях, которые
    исполнять, он знает только их ид-ключи в текстовом виде
    (и текущую точку исполнения).
- нужно запустить событие, которое бы заставило `saga-runtime`
  выполнять текущие действия.

=> а какие действия являются текущими?

<br/>+ а что, если это загруженное продолжение?<br/>

- т.е. до этого была сессия работы
- в ней были запущены свои `saga-functions`
- в какой-то момент состояние зафиксировали
- и вот теперь это состояние загрузили и возобновляют работу с него.

<br/>
Выходит надо:

1. знать все `saga-functions` которые могут быть запущены.
   И это некая статика, в том смысле, что добавлять в процессе выполнения
   ещё какие-либо `saga-functions` чревато поломкой `stateTrevelInTime feature`,
   т.к. при перезапуске `saga-runtime` не сможет передать им управление.

2. неким образом знать стартовую функцию, так что-бы:

   - при чистом запуске после `dispatch(launchAction)` `saga-runtime`
     начал выполнять стартовую функцию;

   - при запуске с заданным состоянием после `dispatch(launchAction)` `saga-runtime`
     начал выполнять всё то, что у него в списке выполнения
     в загруженном состоянии есть.

3. выполнить `dispatch(launchAction)`, на запуск которого влияет:
   - наличие `redux-dev-tools`, у которого специфическая загрузка
     сохранённого состояния
   - потребность запустить без учёта `redux-dev-tools`
   - потребность запустить без автоматического `dispatch(launchAction)`

## Порядок запуска v2

1. объявить все `saga-funcions`

   ```javascript
   const mySaga1 = createSaga(
     () => {},
     () => {}
   );

   const mySaga2 = createSaga(
     () => {},
     () => {}
   );
   ```

2. `createSagaMiddleware()`, куда передать все `mySaga1`, `mySaga2`, ...
   При этом, первая в списке `mySaga1` - будет той,
   что запускаем при чистом старте.

3. `createStore(sagaMiddleware)` - подключить `sagaMiddleware` в `store`.

4. `sagaMiddleware.run(ignoreReduxDevTools = false)` - вот этот метод внутри
   должен реализовать сложную логику запуска. При этом, если его не вызвать, то
   работать всё равно должно, если руками вызвать `dispatch(launchAction)`
   (на панели `redux-dev-tools` есть возможность запускать свои события).

# Что должна делать функция `proceedMiddlewareCall()`?

## Первые предположения

Т.е. `proceedMiddlewareCall()` - это внутренняя часть `redux Middleware`.
`redux` вызывает её при каждом `dispatch(action)`.

Вот, значит:

- должен быть список ожидающих `saga-effect`
- `saga-effect` должны управляться событиями

Тогда `proceedMiddlewareCall()` должна сопоставить текущее событие `action.type`
со списком ожидаемых событий и если кто-то его ждёт, этого кого-то запустить.

## А что там в `redux-saga`?

```javascript
const proceedMiddlewareCall = (next) => (action) => {
  if (sagaMonitor && sagaMonitor.actionDispatched) {
    sagaMonitor.actionDispatched(action);
  }
  const result = next(action); // hit reducers
  channel.put(action);
  return result;
};
```

Вот такой код в `redux-saga` для этой функции.

`channel = stdChannel()` - по умолчанию такой канал.

`channel.put = input=>asap(() => { [multicastChannel()].put(input) })`

Т.е. есть `multicastChannel()` к которому можно подписаться на прослушку
событий. Т.е. по `[multicastChannel()].put(input)` - идёт оповещение
всех подписавшихся, при этом возможно с фильтрацией.

И вот вопрос - откуда подписки берутся у `rootSaga`?
<br/> + да и вообще, откуда подписки в канал берутся у `saga` других?

## А что там в `redux-saga` при вызове `sagaMiddleware.run(mySaga)` происходит?

Т.е. `proceedMiddlewareCall()` берёт на себя 2 обязанности:

- сделать то, что происходит в `sagaMiddleware.run(mySaga)` - если это
  чистый запуск и сейчас происходит `dispatch(launchAction)`
- делать аналог того, что в `redux-saga` происходит в обычном режиме.

`sagaMiddleware.run(mySaga)` внутри вызывает:

```javascript
immediately(() => {
  const task = proc(
    env,
    iterator,
    context,
    effectId,
    getMetaInfo(saga),
    /* isRoot */ true,
    undefined
  );

  if (sagaMonitor) {
    sagaMonitor.effectResolved(effectId, task);
  }

  return task;
});
```

`proc(...)` -> `next()` -> `result = iterator.next(arg)`
-> `digestEffect(result.value, parentEffectId, next)`
-> `runEffect(effect, effectId, currCb)`
-> тут выбор что делать в зависимости от того что за эффект

Есть `effectRunnerMap`. Например `effectTypes.TAKE` внутри
делает `channel.take(...)`, т.е. вот тут происходит подписка.

Если это просто итератор - то у него берём следующее действие.

## Промежуточные выводы по `redux-saga`

В нём есть `packages/core/src/internal/proc.js:proc()` - функция, которая
"крутит" последовательность:

- взять у итератора следующую команду;
- выполнить команду (непосредственно сейчас либо дождаться её выполнения);
- опять взять следующий шаг у итератора, подставив ему в параметры
  результаты выполнения команды.

"Прокручивание" этой цепочки начинается из 2-х мест:

- при вызове `sagaMiddleware.run(mySaga)`;
- внутри `proceedMiddlewareCall()` при `dispatch()`. Соответственно это
  может запустить один из ожидающих эффектов, что запустит "прокручивание".

## Второе приближение

В state должна быть часть для `sagaMiddleware`. Эта часть будет хранить:

- список (в виде объекта) активных эффектов;
- дерево задач. Тут вообще начало от `rootSaga`, но нужно учитывать,
  что `rootSaga` может сделать `spawn`запустив при этом отдельную задачу (не
  привязанную к текущей).

При этом, каждый `dispatch()` вызывает `proceedMiddlewareCall()`, в котором:

- в начале получаем новое состояние
- потом проходим по всем эффектам и задачам "применяя" указания
  появившиеся в их состояниях.

Таких указаний может быть несколько. В соответствии с жизненными
циклами эффектов и задач.

# Какими должны быть жизненные циклы `saga-runtime`, эффектов, задач с учётом возможностей `redux-dev-tools`?

## Первое приближение

Предположим, что:

- в `saga-runtime` был передан набор функций;
- был создан `store` с `proceedMiddlewareCall()` от данного `saga-runtime`;
- в `store` был добавлен `saga-reduser` (который в начале даёт пустое состояние,
  информирующее о том, что ещё ничего не происходило).

И в этих условиях происходит `dispatch(launchAction)`.

Что при этом должно произойти?

- Из `saga-runtime` каким-то образом надо получить идентификатор
  первой `saga-function`.
- `saga-reduser` каким-то образом должен получить идентификатор
  первой `saga-function` и создать под неё состояние `root` задачи,
  в котором сохранить:
  - идентификатор текущей `saga-function`;
  - первый индекс выполнения в `saga-function`;
  - маркер, который будет иметь значение _требуется запустить_.
- `saga-reduser` в своей глобальной части должен запомнить что процесс запущен.
- `saga-runtime` должна прочитать из `saga-state`:
  - маркер, что процесс запущен;
  - состояние `root` задачи;
- `saga-runtime` должна:
  - сопоставить состояние `root` задачи со своей
    внутренней картой запущенных задача;
  - выявив несоответствие - запустить `asap(root-task)` и сохранить в своей
    внутренней карте, что эту задачу она запланировала.
- планировщик, получив `asap(root-task)` должен запустить этот `root-task`.
  Т.к. других сообщений он пока что не получал.
- `root-task` должен выполнить текущую часть `saga-function` и
  в зависимости от результата:
  - перейти к следующей части `saga-function` (если она есть)
  - отловить исключение от исполнения текущей части `saga-function`
  - запланировать эффект, что:
    - переведёт `root-task` в состояние ожидания эффекта
    - добавит в `saga-state` описание эффекта с маркером, что его надо запустить.

## Какими параметрами описывать задачу?

# Как взаимодействовать с не `stateTrevelInTime` миром?

## Что это за взаимодействие может быть?

Классификация по направлению:

- внешний мир что-то передаёт в `stateTrevelInTime`;
- `stateTrevelInTime` что-то передаёт во внешний мир.

Классификация по передаваемой сущности:

- вызов произвольной функции;
- вызов фиксированной функции;
- передача сериализуемых параметров;
- передача не сериализуемых параметров;

Произвольная функция - т.е. любая, в том числе и созданная в точке вызова.
Произвольная в том смысле, что её не определили до создания `saga-runtime`.

Фиксированная функция - т.е. такая, которую некоторым образом определили
до создания `saga-runtime`. Т.е. `saga-runtime` может запомнить адрес такой
функции в виде строки и может потом обратиться по этому _адресу из строки_
к данной функции.

# Как работает redux-dev-tools?

Основной вопрос, это отловить его состояние:

# Какие идеи лежат в основе `redux`? как они повлияли на `redux-dev-tools`? как они должны повлиять на `redux-saga-in-state`?  

Корневая идея `redux`: 
+ есть одно большое состояние, 
+ его изменяют событиями (сериализуемыми сообщениями), 
+ кто угодно событие запустить может
+ все об запуске события уведомляются
+ по текущему состоянию "отрисовываем" интерфейс
+ при запуске `dispatch()` внутри `store.subscribe(()=>dispatch())` происходит уход в рекурсию

## как работает `redux-dev-tools` при переходе на другое состояние (не путём dispatch(action))?

т.е. при загрузке состояния либо переходе по истории либо исключении какого либо из action-ов в истории.

На примере изучения логов от `\demo\counter` выходит, что `redux-dev-tools`:
+ может заблокировать `dispatch()` не допустив его до изменения состояния и оповещения подписанных;
+ может прогнать события через `reduser` переданный в `store`, т.е. запустить последовательность событий без указанных 
  и получить результирующее состояние;
+ может вызвать оповещение всех подписавшихся без запуска `dispatch()`.

Тогда для `redux-saga-in-state` есть 2 точки подписки на происходящее:
+ в `redux-middleware`, что позволит отлавливать запускаемые события (когда их запускают);
+ в `store.subscribe`, где слушать изменения состояния, которое может произойти не только от запуска `action`.


# Минимальный запуск — что для этого надо (2.0.0)?

Учитывая поведение `redux-dev-tools` (смена состояния без `dispatch()`) возникает вопрос о том, что с этим делать?

Предположим минимальное приложение должно открыть страничку, 
выполнить запрос за данными, отобразить данные,
позволить запустить ещё один запрос 
и иметь в наличии счётчик количества выполненных запросов.

Помимо этого, при выполнении запроса должна появляться возможность
его прервать.

Предполагаемая реализация.

Из корневой saga запустить слушателя, который должен отлавливать события запуска загрузки.
После прихода события запустить дочернюю задачу загрузки, сохранив идентификатор задачи.
И запустить слушателя 2-х событий:
.загрузка завершилась
.прервать загрузку

Дочерняя задача загрузки:
.запускает событие загрузка началась
.запускает саму загрузку — эффект fetch
.проверяет результат вызова:
    .если загрузилось — событие загрузка завершена.
    .во всех остальных случаях: ошибка либо прерывание загрузки — просто завершение.

В основном потоке получить одно из двух событий. Если это о прерывании загрузки — через
идентификатор дочерней задачи послать сигнал прерывания задачи.
В любом случае вернутся к прослушиванию события начало загрузки.

Далее состояние для ui:
.количество загрузок по успешному событию считать
.индикатор что-бы отлавливать начало загрузки и завершение либо отмену

! можно демо для этого примера написать, исключительно со статическими reducer-ами. 
И только необходимым набором эффектов. Даже ядро `redux-saga` можно как-то минимизировать.